并发编程Bug的来源
由缓存引起的可见性问题：一个线程修改的共享变量，能够立即被其他线程看到。
由线程切换引起的原子性问题：一个或多个操作在CPU执行的过程中不被中断的特性叫做原子性。
有编译优化带来的有序性问题：按照程序的编码的顺序执行叫做有序性。

Java内存模型，解决可见性和有序性问题
Happens-before原则
1. 程序的顺序性原则：在一个线程中，按照程序顺序，前面的操作happens-before于后续的任意操作。
2. volatile变量原则：对于一个volatile变量的写操作 happens-before于后续对这个变量的的读操作。禁用缓存。
3. 传递性原则：如果A  happens-before B, B happens-before C ,那么 A happens-before C。
4. 管程中锁的规则：一个锁的解锁happens-before于对这个锁的加锁操作。
5. 线程start原则：如果线程A start 线程B ，那么start操作 happens before于线程B的任意操作。
6. 线程join原则：如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。
7. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
8. 对象终结规则：一个对象的初始化完成(构造函数执行结束)happens-before它的finalize()方法的开始。

互斥锁，解决原子性问题 synchronized
加锁时，要考虑清楚 锁 和受保护资源之间的关联关系，这非常重要。
如何保护多个资源：关键是要分析多个资源之间的关联关系，没有关联关系的，每个资源一把锁，有关联关系的，就要选择粒度更大的锁，能够覆盖所有的相关资源。
要解决原子性问题：就要保证中间状态对外不可见。

死锁条件：
1. 互斥:
2. 占有且等待 : 一次性申请所有资源
3. 不可抢占： 申请不到资源后主动释放资源
4. 循环等待： 给资源编号，按序申请。

完整的等待-通知机制：
线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态，当线程要求的条件满足时，通知等待的线程，重新获取互斥锁。

并发编程需要注意的问题：
1. 安全性问题：
  含义：按照程序期望的顺序执行。
  如何做到：避免出现可见性、原子性、有序性的问题。
  何时考虑：有共享数据且该数据会发生变化。通俗的讲就是多个线程会同时读写同一个数据。
  数据竞争：当有多个线程同时访问同一数据，并且至少一个线程写这个数据的时候，就叫做数据竞争。
  竞态条件：程序的执行结果依赖线程执行的顺序。
  数据竞争和竞态条件都可以用互斥的方式来解决
2. 活跃性问题
  死锁：破坏死锁条件  (占有且等待：一起申请锁；不可抢占：超过一定时间就释放锁；循环等待：对资源id进行排序，按序申请)
  活锁：线程随机等待时间
  饥饿：1）保证资源充足 2）公平的分配资源 3）避免持有锁的资源长时间执行。
3. 性能问题
  性能方面的度量指标有很多，我觉得有三个指标非常重要，就是：吞吐量、延迟和并发量。
  吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
  延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。
  并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。

管程：并发编程的万能钥匙
信号量的应用：1）利用信号量实现临界区的互斥访问 2）利用信号量实现进程间同步 3）利用信号量实现生产者-消费者模型
信号量的组成 semaphore：一个资源，一个等待队列，P、V原语。
管程的组成：入口等待队列，共享变量，多个条件变量及对应的等待队列，以及对共享变量的操作方法

Java线程生命周期
1. 通用线程模型及对应到Java线程模型中
  新建（NEW）
  可运行/运行(RUNNABLE)
  休眠（BLOCKED、WAITING、TIMED_WAITING）
  终止（TERMINATED）
2. Java线程状态转换
  NEW->RUNNABLE:调用了线程的start()方法
  RUNNABLE->BLOCKED: 线程等待synchronized的隐式锁。
  RUNNABLE->WAITING:已经获取synchronized隐式锁的线程显示调用 wait(),或者调用线程的join和sleep方法，或调用LockSupport.park()方法
  RUNNABLE->TIMEED_WAITING:调用待超时参数的 导致 RUNNABLE->WAITING 的方法
  RUNNABLE->TERMINATED:线程的run方法执行完毕或者抛出interputedException异常。 
3. 中断
这说明: interrupt中断的是线程的某一部分业务逻辑，前提是线程需要检查自己的中断状态(isInterrupted())。
但是当线程被阻塞的时候，比如被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞时。调用它的interrput()方法。可想而知，没有占用CPU运行的线程是不可能给自己的中断状态置位的。这就会产生一个InterruptedException异常。

创建多少线程合适
1. 对于CPU密集型：线程数=CPU核数+1
2. 对于I/O密集型：线程数=CPU核数*（1+ I/O耗时 / CPU耗时数 ）
基本原则：将硬件的性能发挥到极致

为什么局部变量是线程安全的
因为每个线程都有自己独立的调用栈，而每个方法在被调用时，都会在该线程的的调用栈中分配空间用来存储局部变量，因此，局部变量不会被共享，也就没有伤害。

用面向对象的方法写好并发程序
1. 封装共享变量
2. 识别共享变量之间的约束关系
3. 制定并发访问策略

Lock和Condition
1. 再造管程的理由：synchronized进入阻塞的时候什么都干不了
 - 能够响应中断
 - 支持超时
 - 非阻塞地获取锁
2. 可重入锁 ReentrantLock：同一个进程可以重复获取同一把锁

Semaphore:信号量->快速实现限流器
信号量模型：一个信号量，一个队列，三个方法（acquire(), release(), init()）
Semaphore允许多个线程访问一个临界区。

ReadWriteLock 使用场景：
final ReadWriteLock rdLock = new ReadWriteReentrantLock()
final Lock rlock = rdLock.readLock();
final Lock wlock = rdLock.writeLock();
1. 允许多个线程同时读共享变量。读锁不支持条件变量
2. 指允许一个线程写共享变量。写锁支持条件变量。
3. 当线程写共享变量时，禁止其他线程读共享变量。
4. 获取写锁的前提是没有其他线程获取读锁和写锁。
5. 同一个线程获取写锁之后可以获取读锁。
6. 申请写锁时不中断其他线程申请读锁，公平锁如果过有写申请，能禁止读锁。

StampedLock
提供三个锁，悲观读锁，悲观写锁，乐观读
StampedLock 使用注意事项
1. StampedLock 在命名上并没有增加 Reentrant，StampedLock 不支持重入
2. StampedLock 的悲观读锁、写锁都不支持条件变量
3. 如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升.
4. 使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()
5. StampedLock 的使用是有读写模板的。

CountDownLatch和CyclicBarrier
1. CountDownLatch主要用来解决一个线程需要等待多个线程的场景，不能循环计数
2. CyclicBarrier主要用来解决多个线程相互等待，可以循环计数和自动重置功能，还可以设置回调函数
注意：CyclicBarrier的回调函数执行在一个回合里最后执行await()的线程上，而且同步调用回调函数check()，调用完check之后，才会开始第二回合。所以check如果不另开一线程异步执行，就起不到性能优化的作用了。

Java并发容器
Java原子类

线程池
1. 线程池要素：一组工作线程负责消费，一个等待队列，一个循环方法判断队列是否为空


Future：接口，用于获取执行Callable接口任务的结果，以及一些对线程状态的查询于操作，中断，取消等
FutureTask：实现类，实现了Future接口和Runnable接口,底层将Runnable接口适配成Callable接口
CompletableFuture：实现类，实现了Future接口和 CompletionStage接口，用于实现异步编程，串行，并行，聚合关系。
CompletionStage：接口 提供了串行、汇聚（AND、OR）关系以及异常处理的函数接口
CompletionService：接口，接受 Callable和Runnable，实现批量执行。
ForkJoin：并行计算框架，分治任务模型：一个ForkJoinPool，一个ForkJoinTask<T>

待补知识点：内存泄漏，垃圾回收;消息队列中间件原理


方法区：
已经被加载的类信息、常量、静态变量、即时编译器编译后的代码等。

类的元信息->元空间->本地内存
静态变量、常量->堆中

运行时常量池->Class文件中的常量池（编译器生成的字面量和符号引用）

类卸载条件：
1. 该类的所有实例都已经被回收，此时堆中没有该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

引用
强引用：被强引用的对象不会被回收。
软引用：当内存不够时就会被回收。
弱引用：每次垃圾回收的时候一定会被回收。
虚引用：幻引用，不影响对象的生命周期，仅在垃圾回收时发送一个通知。
